{"name":"Identifying Fraud from Enron Email using Machine Learning","tagline":"Chi-Yuan Cheng, Udacity Data Analyst Nanodegree","body":"##Project 4: Identifying Fraud from Enron Email  (Intro Machine Learning)\r\n- Author:  Chi-Yuan Cheng (cyuancheng AT gmail DOT com) \r\n- Last updated: August 4, 2015\r\n\r\n###1. Information\r\n\r\nEnron was an infamous American company which was known for its extensive fraud. Enron marketed electricity and natural gas, delivered energy and other physical commodities around the world. It was once ranked the sixth largest energy company in the world. Most of the top Enron's executives were tried for fraud after it was revealed in November 2001 that Enron's earnings had been overstated by several hundred million dollars. Enron paid the top 140 executives $680 million in 2001. Among others, Kenneth Lay (founder, chairman of the Enron board directors) received $67.4 million and Jeffrey Skilling (former CEO) received $41.8 million. Moreover, the top executives sold their company stock prior to the company's downfall. The Enron scandal was one of the five largest audit and accountancy partnerships in the world and Enron was cited as the biggest audit failure.\r\n\r\nOn the other hands, the Enron Corpus is believed to be one of the largest publicly available collection of real-world email data. It has been widely used for research in social network analysis, natural language processing, and machine learning. The Enron financial records of former executives and employees were also released during the fraud trials.  \r\n\r\nThe goal of this project is to develop machine learning algorithm, together with scikit-learn Python module, to predict the person of interest (POI) of a fraud from the email and financial (E+F) dataset. POIs were ‘individuals who were indicted, reached a settlement, or plea deal with the government, or testified in exchange for prosecution immunity.’  The E+F dataset from the Enron Corpus was used as features for the POI prediction.\r\n\r\n### 2. The Enron Data\r\n\r\nEnron E + F dataset, which can be download on the Internet.\r\n\r\nIt contains:\r\n  \r\n  +  Length of dataset: 146\r\n  +  Number of feature: 21\r\n  +  POIs : 18 (the poi feature set as ```True```)\r\n\r\nThere are many features with missing values (NaN) in the dataset:\r\n\r\n| features       | Numbers of NaN        | \r\n| ------------- |:-------------:| \r\n|```loan_advances```  |     142|\r\n| ```director_fees ```   | 129 | \r\n|```restricted_stock_deferred``` |   128|\r\n| ```deferral_payments```     | 107 | \r\n|```deferred_income```   |97|\r\n|```long_term_incentive```  |         80|\r\n| ```bonus```   |                      64|\r\n|```shared_receipt_with_poi```   |    60|\r\n|```from_this_person_to_poi```  |     60|\r\n|```from_messages ```  |              60|\r\n|```to_messages ``` |                 60|\r\n|```from_poi_to_this_person```     |  60|\r\n|```other ```       |                 53|\r\n|```expenses ```  |                   51|\r\n|```salary ```                      | 51|\r\n|```exercised_stock_options```|       44|\r\n|```restricted_stock```   |           36|\r\n|```email_address```     |            35|\r\n|```total_payments ```   |            21|\r\n|```total_stock_value ```  |          20|\r\n\r\n\r\nThe features in the dataset are listed below:\r\n\r\n*financial feature:*\r\n\r\n```\r\n'bonus', 'deferral_payments', 'deferred_income', 'director_fees', \r\n'exercised_stock_options', 'expenses', 'loan_advances', 'long_term_incentive',\r\n 'other', 'restricted_stock', 'restricted_stock_deferred',\r\n 'salary', 'total_payments', 'total_stock_value'\r\n```\r\n*email feature:*\r\n\r\n```\r\n'email_address', 'from_messages', 'from_poi_to_this_person', \r\n'from_this_person_to_poi', 'to_messages', 'shared_receipt_with_poi', \r\n```\r\n\r\n\r\n### 3. Feature Processing\r\n#### Outliers\r\n\r\nI removed the following entries in the dataset.\r\n\r\n1. The ```TOTAL```  is the summation of all the data points for each feature, and it is the biggest Enron E+F dataset outlier. \r\n2. The```THE TRAVEL AGENCY IN THE PARK``` is a travel agency, not the name of employee at Enron.\r\n3. The ```LOCKHART EUGENE E``` missed all the feature values, and is not very useful in the dataset.\r\n4. The ```email_address``` feature is also a outliner, because it is a person's email address and is not useful to identify POIs.\r\n\r\nThis dataset contains lots of missing values (NaN). Many machine learning models don't like NaN. If we just fill the NaN values with zero, it may bias the data towards low values. The solution here is to fill the NaN values with median values for each feature.\r\n\r\nIn addition, there are three outliers in the features of salary and bonus. Two people (Jeffrey Skilling, Kenneth Lay) made salaries more than 1 million dollars, and two people (John Lavorato, Kenneth Lay) made a bonus of over 7 million dollars. However, I decided to not remove these extreme values from the dataset. It is because these extreme values might significantly affect the fraud at Enron and could be key parameters to identity the POIs.\r\n\r\n#### New features\r\n\r\nWe expect that POIs contact with each other more frequently than with non-POIs, so this might be key information to predict POIs. Therefore, I engineered the following three features:\r\n\r\nnew  features       | description          | \r\n| ------------- |:-------------:| \r\n| ```fraction from poi```    | fraction of messages from a PO to that person I | \r\n| ```fraction to poi```     | fraction of messages from that person to a POI      |  \r\n| ```fraction email with poi``` | fraction of messages to and from that person to a POI     |  \r\n\r\nAs will be evaluated in more detail later, these new features did not improve the overall performance of the final algorithm, so they were not included in the final model.\r\n \r\n#### Feature Selection\r\n\r\nBefore feeding the features into any models, it is necessary to scale the feature values to be between 0 and 1. It is because if one feature has a broad range of values, the outcome will be governed by this particular feature. Therefore, the range of all feature values need to be normalized, so that each feature contributes approximately proportionately to the final outcome.\r\n\r\nI used SelectKBest to search the best features in E+F feature list, according to the ANOVA F-value classification scoring function, as below. This step can get rid of some unnecessary features that may overfit the predictive model.\r\n\r\n![selected features](https://raw.githubusercontent.com/cyuancheng/Intro-Machine-Learning/master/Fig_SelectKBest_features.png \"Selected features\")\r\n\r\n\r\nThe top 15 features from SelectKBest were fed to the DecisionTreeClassifier algorithm to determine the feature importance. \r\n\r\n![feature importance](https://raw.githubusercontent.com/cyuancheng/Intro-Machine-Learning/master/Fig_importance.png \"feature importance\")\r\n\r\nI then removed the features by hand to optimize the score of the model. \r\nFinally, I chose the following features:\r\n\r\n```\r\n'exercised_stock_options', 'total_stock_value',\r\n 'bonus', 'salary',  'deferred_income'\r\n```\r\n\r\n###4. Algorithm Selection and Tuning\r\n####Preliminary test\r\nInitially, I fed the top 5 features that were found by SelectKBest to the following six algorithms with default parameters and compared their scores.\r\n\r\n| Algorithm     | Accuracy         |  Precision|  Recall|\r\n| ------------- |:-------------:| :-------------:| :-------------:| \r\n|Logistic Regression|0.8747|0.2100|0.2100|\r\n|LinearSVC| 0.8727|0.3433|0.3433|\r\n| KNeighbors | 0.8680 | 0.1550| 0.1550|\r\n| Random Forest    |0.8547  | 0.2720 | 0.2961| \r\n| AdaBoost| 0.8440| 0.3598| 0.3448|\r\n| Decision Tree  | 0.7800| 0.1955 | 0.2120|\r\n\r\n![model test](https://raw.githubusercontent.com/cyuancheng/Intro-Machine-Learning/master/Figure_models_test_initial.png \"model test\")\r\n\r\nThese models give high accuracies (>0.78), but they have low precision and recall (0.1~0.3). Among these tested models, *LinearSVC* and *AdaBoost* have precision and recall scores above 0.3.  \r\n\r\n####  Analysis Validation and Performance\r\n\r\nTuning the parameters of algorithm means to optimize the performance of the model to the particular features in the dataset. The performance can be determined by accuracy, precision, and recall scores. Here, I fined tune the parameters of ***LinearSVC*** and  ***AdaBoost***  to get the optimal performance of the models.  \r\n\r\nTo optimize the performance of model, I first scales the selected features to be between 0 and 1 using MinMaxScaler. The scaled features was fed into Principal Components Analysis (PCA) dimensional reduction algorithm as a part of GridSearchCV pipeline, when searching the optimal estimator parameters for particular classification algorithm. These two steps were used during each cross-validation step for the grid search and optimal parameters. \r\n\r\nFinally, I end up using ***AdaBoost*** (with optimal Decision Tree estimator) , because its scores of precision and recall are the highest among other algorithms (> 0.3). The scores using for optimal AdaBoost and LinearSVC are below\r\n\r\n| Algorithm     | Accuracy         |  Precision|  Recall|\r\n| ------------- |:-------------:| :-------------:| :-------------:|\r\n| AdaBoost| 0.8227| 0.3318| 0.3650| \r\n|LinearSVC| 0.8733|0.3433|0.2200|\r\n\r\nThe optimized parameters for AdaBoost is:\r\n\r\n```\r\nPipeline(steps=[('pca', PCA(copy=True, n_components=3, whiten=False)), ('clf', AdaBoostClassifier(algorithm='SAMME.R',\r\n          base_estimator=DecisionTreeClassifier(class_weight=None, criterion='gini', max_depth=None,\r\n            max_features=None, max_leaf_nodes=None, min_samples_leaf=1,\r\n            min_samples_split=0.316227766017, min_weight_fraction_leaf=0.0,\r\n            random_state=42, splitter='random'),\r\n          learning_rate=0.5, n_estimators=1, random_state=42))])\r\n\r\n``` \r\n\r\nThe classic way of doing *validation* is to separate dataset into a training set and a testing set, and train the specific model on the training set. Then we test our model on the testing set to see how the performance evaluated from predicted values of the testing set match up the actual values for the testing set. Although this strategy can avoid overfitting data to our models, validation can go wrong if data splitting is biased. For example, in some cases, valuable information is only contained in the test set, not in the training set, or the size of the dataset is very limited. A proper way to solve these problems are to randomly select the observations for the test set (Stratified Shuffle Split validation) or to split dataset into multiple-consecutive sets (k-fold validation), and take the average of the testing results generated by the classifier. \r\n\r\nIn this project, I validated the dataset using StratifiedShuffleSplit function provided by sklearn. The n_iter (represented by the folds variable) was set to 100, and  I used 90% data to train the model and 10% data to test the model. That means the model randomly samples 90% (10%) data to train (test) the model for each iteration, and averaged the scores for the model validation. \r\n\r\nFinally, let's compare the performance of final model before and after adding the new features. \r\n\r\n![new features](https://raw.githubusercontent.com/cyuancheng/Intro-Machine-Learning/master/Figure_new_features.png \"new features\")\r\n\r\nI found that these new features do not significantly improve the performance of the final model; therefore, they are not include in the feature list.\r\n\r\n###5. Discussion and Conclusions\r\n\r\n* Accuracy: It represents the ratio of correct prediction out of the total prediction made. In other words, it means how many percentage of POIs the model can correctly predict. The average accuracy for optimal AdaBoost model is 0.8227, which means 82.27 % of predictions this model made were correct.\r\n\r\n* Precision: It represents the ratio of correct positive prediction (True positives) made out of the total positive prediction made (True positives + False positives) . Here, the positive prediction means predicting the employee who is a POI (POI returns \"1\"). The average precision of the optimal AdaBoost model is 0.3318, which means that 33.18 % of the total positive prediction made by model were correct.\r\n\r\n* Recall: It represents the ratio of correct positive prediction (True positives) made out of the actual total predictions, that were indeed positive (True positives + False negatives). The recall value in this project means what percentage of actual POIs in the test dataset were correctly identified. The optimal AdaBoost model achieves a recall of 0.3650, which means only 36.50 % of POI were correctly identified among all the actual POIs.\r\n\r\nIn many cases, the accuracy can be pretty good (>80%), but still lacking good precision or recall (<30%). It is important to note that a model has a very high accuracy does not mean it is a good model. There is also a trade-off between precision and recall, which needs to be balanced in the models. However, the Enron E+F dataset contains much more POIs than non-POIs (18 vs 127). With this unbalanced dataset, the precision and recall are useful metrics for evaluating the model. For example, the original Enron data contains 18 POIs over 145 employee. The optimal AdaBoost model can successfully identify 15 individual as POIs, where only 5 of them actually to be POIs. More data will definitely help to improve the performance and validation of models. \r\n \r\n###6. References\r\n\r\n\r\n1. [Enron scandal, from WiKipedia](https://en.wikipedia.org/wiki/Enron_scandal)\r\n2. [Enron Email Dataset](https://www.cs.cmu.edu/~./enron/)\r\n3. [Enron Financial Dataset](http://news.findlaw.com/legalnews/lit/enron/)\r\n4. [EnronData.org](http://enrondata.org/content/research/)\r\n5. [scikit-learn](http://scikit-learn.org/stable/)\r\n6. Python for Data Analysis, by Wes McKinney, O'Reilly Media, 2012.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}